<!DOCTYPE html>
<html lang="en">
	<head>
		<title>TCC</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		<script src="three/build/three.js"></script>
		<!-- CARREGA O THREE.JS -->
		<script src="three/loaders/OBJLoader.js"></script>
		<!-- CARREGA O CARREGADOR DE OBJETO -->
		<script src="three/controls/OrbitControls.js"></script>
		<!-- CARREGA OS CONTROLES -> ORBIT CONTROLS -->
		<script>
			var container;
			// variavel comum declarada, quando ela for referenciada explico o propósito
			var camera, scene, raycaster, renderer;
			// variaveis comuns declaradas, quando elas forem referenciadas explico o propósito
			var mouse = new THREE.Vector2(), INTERSECTED;
			// variavel mouse declarada, e referenciada a partir do construtor Vector2 (vetor bidimensional)

			var mouseX = 0, mouseY = 0;
			// variaveis comuns declaradas, quando elas forem referenciadas explico o propósito

			var windowHalfX = window.innerWidth / 2;
			// desconsiderar
			var windowHalfY = window.innerHeight / 2;
			// desconsiderar

			var acuX = 0, acuY = 0, acuZ = 0;
			//inicialização de variaveis globais a serem usadas para a animação de camera

			var focoCamera = false;
			//variavel global que controlará a animação de câmera (ativar/desativar animação)
			var uPressed = false;
			var dPressed = false;
			var rPressed = false;
			var lPressed = false;
			var pPressed = false;
			var mPressed = false;
			var idponto = 'e1';
			var p = new THREE.Vector3( 0, 0, 0 );

			init();
			/* aqui é chamada a função init(); o fluxo de execução do código entra nesta função assim que ela é chamada, seguindo todas as instruções contidas em init(); e ao término, volta para este ponto e segue com a execução do comando na linha 87 */
			animate();
			/* aqui é chamada a função animate(), que é propriamente acessada logo após o controle de execução passar por toda a função init() que foi chamada anteriormente. Ao explicar a função animate, perceberá que ela é uma função recursiva. Quando essa função é chamada, o fluxo de execução não sai mais dela, uma vez que ela chama a si própria indefinidamente */

			function init() {
				/* declaração da função init() => o propósito dela é exatamente como o próprio nome diz, inicialização. */
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				/* anexa ao corpo BODY do HTML o container, que neste caso é um elemento DIV */

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 10, 2000 );
				/* declara uma câmera, do tipo PerspectiveCamera. Vide documentação do Three.js para explicá-lo.

				*/
				camera.position.z = 250;
				/* posiciona a câmera inicialmente 250 pixeis a frente do centro (0) */
				controls = new THREE.OrbitControls( camera );
				/* declara os controles em função da câmera do tipo OrbitControls. Permite o uso de controles em volta de um objeto, segurando o botao direito do mouse faz a camera girar em função da câmera, girando o scroll faz aumentar/diminuir o eixo Z da câmera (zoom), segurando o botao esquerdo faz a posição como um todo da camera deslocar-se. Não possui documentação, portanto a explicação será breve. */
				controls.damping = 0.2;
				controls.addEventListener( 'change', render );

				scene = new THREE.Scene();
				/* cria um novo objeto do tipo CENA, que permitirá o meio por onde a renderização será feita. Como também será onde adicionaremos objetos, luzes e câmeras.
				Vide https://threejs.org/docs/?q=scene#Reference/Scenes/Scene
				*/

				var ambient = new THREE.AmbientLight( 0x101030 );
				/* Cria uma luz ambiente de cor 0x101030, afetando globalmente os objetos na cena. Como se fosse o Sol.
				Esse construtor recebe 2 parâmetros: cor RGB (no caso 0x101030) e INTENSIDADE (que no caso foi omitida [o que faz o programa usar a definição padrão de intensidade]) Vide documentação do Three.js para mais informações. https://threejs.org/docs/?q=ambient#Reference/Lights/AmbientLight
				*/
				scene.add( ambient );
				/* Invoca o método add do objeto scene que foi construído na linha 104, passando como parâmetro a variável ambient ( que recebeu a construção do método THREE.AmbientLight) - linha 107

				Resumo: adiciona a luz ambiente na cena.
				*/


				var directionalLight = new THREE.DirectionalLight( 0xffeedd );
				/* Armazena o resultado do construtor DirectionalLight na variavel directionalLight
				é passado como parâmetro a cor RGB 0xffeedd.
				Este construtor cria uma luz em modo direcional, como se fosse uma lâmpada.
				Vide https://threejs.org/docs/?q=directional#Reference/Lights/DirectionalLight*/
				directionalLight.position.set( 0, 0, 1 );
				/* acessando o objeto position e invocando o método set estamos definindo a posição da luz, que neste caso é (0, 0, 1) ou seja: uma lâmpada paralela ao eixo Z, emitindo a luz de frente. */
				scene.add( directionalLight );

				/* Invoca o método add do objeto scene que foi construído na linha 104, passando como parâmetro a variável directionalLight ( que recebeu a construção do método THREE.DirectionalLight) - linha 107

				Resumo: adiciona a luz direcional na cena.
				*/

				var directionalLight = new THREE.DirectionalLight( 0xffeedd );
				directionalLight.position.set( 0, 0, -1 );
				/* Mesma coisa como na parte acima. A única diferença é que neste caso a direção da luz é (0, 0, -1) ou seja: uma lâmpada paralela ao eixo Z, porém inversa, emitindo a luz de trás. */
				scene.add( directionalLight );
				/* mesma coisa que em cima, adiciona a luz direcional na cena*/

				var geometry = new THREE.SphereGeometry( 0.3, 32, 32 );
				/* armazena em geometry o resultado do construtor SphereGeometry, que recebe como parâmetro 

				raio — raio da esfera. Neste caso 0.3.
				widthSegments — número de segmentos horizontais isso influencia na lapidação da esfera. Neste caso 32.
				heightSegments — número de segmentos verticais isso influencia na lapidação da esfera. Neste caso 32.

				Geometria que será usada para todas as esferas no programa - ACUPONTOS 

				*/

				/*Aqui estão as declarações de todas as esferas, elas são análogas, a diferença será apenas os nomes e posicionamentos: */

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				/* vide https://threejs.org/docs/#Reference/Objects/Mesh */

				object.nome = 'cs7';
				/* cria um atributo nome, que será usado para mapear os botões na página pai. Para abrir a opção quando clica na esfera que é representada no espaço tridimensional */
				object.position.x = -24.71516683000315;
				object.position.y = -6.555406638283143;
				object.position.z = 0.6;
				/*posições no espaço - definidas basicamente por testes exaustivos e comparação com o referencial*/
				scene.add( object );
				/* adiciona o acuponto */

				/*abaixo estão declaradas as outras esferas da mesma forma, mudando apenas posicionamento e nomes*/

				var geometry = new THREE.SphereGeometry( 0.3, 32, 32 );

				/* INÍCIO MERIDIANO EXTRAORDINÁRIO - VASO CONCEPÇÃO */

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc2';
				object.position.x = 0.05;
				object.position.y = -6;
				object.position.z = 6.4;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc3';
				object.position.x = 0.05;
				object.position.y = -2.9;
				object.position.z = 7.1;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc4';
				object.position.x = 0.05;
				object.position.y = 0.20000000000000018;
				object.position.z = 7.17;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc5';
				object.position.x = 0.05;
				object.position.y = 3.3000000000000007;
				object.position.z = 7.25;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc6';
				object.position.x = 0.05;
				object.position.y = 6.4;
				object.position.z = 7.3;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc7';
				object.position.x = 0.05;
				object.position.y = 9.5;
				object.position.z = 7.2;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc8';
				object.position.x = 0.05;
				object.position.y = 12.7;
				object.position.z = 6.1;

				scene.add( object );
				
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc9';
				object.position.x = 0.05;
				object.position.y = 15.9;
				object.position.z = 6.1;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc10';
				object.position.x = 0.05;
				object.position.y = 18.4;
				object.position.z = 6.38;

				scene.add( object );
				
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc11';
				object.position.x = 0.05;
				object.position.y = 20.9;
				object.position.z = 6.38;

				scene.add( object );
				
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc12';
				object.position.x = 0.05;
				object.position.y = 23.4;
				object.position.z = 6.58;

				scene.add( object );
				
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc13';
				object.position.x = 0.05;
				object.position.y = 25.9;
				object.position.z = 6.6;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc14';
				object.position.x = 0.05;
				object.position.y = 28.4;
				object.position.z = 5.95;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc15';
				object.position.x = 0.05;
				object.position.y = 30.9;
				object.position.z = 5.06;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc16';
				object.position.x = 0.05;
				object.position.y = 33.4;
				object.position.z = 4.9;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc17';
				object.position.x = 0.05;
				object.position.y = 36;
				object.position.z = 4.7;
				console.log(object.position.y);

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc18';
				object.position.x = 0.05;
				object.position.y = 38.6;
				object.position.z = 3.6;
				console.log(object.position.y);

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc19';
				object.position.x = 0.05;
				object.position.y = 41.2;
				object.position.z = 2.4;
				console.log(object.position.y);

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc20';
				object.position.x = 0.05;
				object.position.y = 43.8;
				object.position.z = 1.2;
				console.log(object.position.y);

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc21';
				object.position.x = 0.05;
				object.position.y = 46.4;
				object.position.z = -0.9;
				console.log(object.position.y);

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc22';
				object.position.x = 0.05;
				object.position.y = 49;
				object.position.z = -2.1;
				console.log(object.position.y);

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc23';
				object.position.x = 0.02;
				object.position.y = 56;
				object.position.z = -0.2;
				console.log(object.position.y);

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.nome = 'vc24';
				object.position.x = 0.02;
				object.position.y = 60;
				object.position.z = 5;
				console.log(object.position.y);

				scene.add( object );
				/* FIM MERIDIANO EXTRAORDINÁRIO - VASO CONCEPÇÃO */

				/* INÍCIO MERIDIANO ZANG FU - PULMAO */

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p1';
				object.nome = 'p1';
				object.position.x = -13.267798006864483;
				object.position.y = 46.00000000000004;
				object.position.z = -1.0999999999999999;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p2';
				object.nome = 'p2';
				object.position.x = -11.26779800686449;
				object.position.y = 48.60000000000008;
				object.position.z = -3.4000000000000026;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p3';
				object.nome = 'p3';
				object.position.x = -22.967798006864573;
				object.position.y = 32.39999999999985;
				object.position.z = -4.7;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p4';
				object.nome = 'p4';
				object.position.x = -23.56779800686458;
				object.position.y = 28.699999999999797;
				object.position.z = -4.999999999999999;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p5';
				object.nome = 'p5';
				object.position.x = -24.16779800686459;
				object.position.y = 15.69999999999962;
				object.position.z = -4.6000000000000005;

				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p6';
				object.nome = 'p6';
				object.position.x = -25.767798006864613;
				object.position.y = 7.499999999999648;
				object.position.z = -2.7000000000000015;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p7';
				object.nome = 'p7';
				object.position.x = -26.96779800686463;
				object.position.y = -1.5000000000003426;
				object.position.z = -1.5000000000000004;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p8';
				object.nome = 'p8';
				object.position.x = -26.26779800686462;
				object.position.y = -3.500000000000344;
				object.position.z = -0.5000000000000001;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p9';
				object.nome = 'p9';
				object.position.x = -27.367798006864636;
				object.position.y = -5.500000000000339;
				object.position.z = -0.30000000000000016;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p10';
				object.nome = 'p10';
				object.position.x = -27.66779800686464;
				object.position.y = -7.7000000000003315;
				object.position.z = 2.1000000000000005;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p11';
				object.nome = 'p11';
				object.position.x = -30.56779800686468;
				object.position.y = -13.200000000000312;
				object.position.z = 5.999999999999995;
				scene.add( object );

				/* FIM MERIDIANO Shou Tai Yin Fei Jing - PULMAO */

				/* INICIO MERIDIANO Shou Yang Ming Da Chang - INTESTINO GROSSO */

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig1';
				object.nome = 'ig1';
				object.position.x = 29.232201993135632;
				object.position.y = -20.00000000000036;
				object.position.z = 6.199999999999994;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig2';
				object.nome = 'ig2';
				object.position.x = 29.332201993135634;
				object.position.y = -14.700000000000307;
				object.position.z = 2.8000000000000007;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig3';
				object.nome = 'ig3';
				object.position.x = 29.532201993135637;
				object.position.y = -12.200000000000315;
				object.position.z = 1.7999999999999998;
				scene.add( object );
				
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig4';
				object.nome = 'ig4';
				object.position.x = 29.532201993135637;
				object.position.y = -10.500000000000322;
				object.position.z = 0.39999999999999936;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig5';
				object.nome = 'ig5';
				object.position.x = 28.33220199313562;
				object.position.y = -6.800000000000335;
				object.position.z = 0.39999999999999925;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig6';
				object.nome = 'ig6';
				object.position.x = 28.032201993135615;
				object.position.y = -0.3000000000003421;
				object.position.z = -3.8000000000000025;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig7';
				object.nome = 'ig7';
				object.position.x = 27.832201993135612;
				object.position.y = 4.399999999999659;
				object.position.z = -6.399999999999994;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig8';
				object.nome = 'ig8';
				object.position.x = 27.73220199313561;
				object.position.y = 9.69999999999964;
				object.position.z = -8.099999999999989;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig9';
				object.nome = 'ig9';
				object.position.x = 27.532201993135608;
				object.position.y = 11.999999999999632;
				object.position.z = -8.799999999999986;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig10';
				object.nome = 'ig10';
				object.position.x = 27.232201993135604;
				object.position.y = 14.299999999999624;
				object.position.z = -9.299999999999985;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig11';
				object.nome = 'ig11';
				object.position.x = 27.0322019931356;
				object.position.y = 17.59999999999964;
				object.position.z = -8.799999999999986;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig12';
				object.nome = 'ig12';
				object.position.x = 26.632201993135595;
				object.position.y = 20.49999999999968;
				object.position.z = -8.599999999999987;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig13';
				object.nome = 'ig13';
				object.position.x = 26.432201993135592;
				object.position.y = 23.499999999999723;
				object.position.z = -9.299999999999985;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig14';
				object.nome = 'ig14';
				object.position.x = 24.73220199313557;
				object.position.y = 33.29999999999986;
				object.position.z = -7.599999999999991;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig15';
				object.nome = 'ig15';
				object.position.x = 20.432201993135507;
				object.position.y = 47.20000000000006;
				object.position.z = -5;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig16';
				object.nome = 'ig16';
				object.position.x = 18.132201993135475;
				object.position.y = 48.80000000000008;
				object.position.z = -6.499999999999995;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig17';
				object.nome = 'ig17';
				object.position.x = 5.532201993135482;
				object.position.y = 54.10000000000016;
				object.position.z = -4.0000000000000036;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig18';
				object.nome = 'ig18';
				object.position.x = 5.132201993135483;
				object.position.y = 56.100000000000186;
				object.position.z = -3.600000000000003;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig19';
				object.nome = 'ig19';
				object.position.x = 0.9322019931354847;
				object.position.y = 62.400000000000276;
				object.position.z = 4.899999999999998;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig20';
				object.nome = 'ig20';
				object.position.x = 1.9322019931354855;
				object.position.y = 62.90000000000028;
				object.position.z = 4.3;
				scene.add( object );

				/* FIM MERIDIANO Shou Yang Ming Da Chang - INTESTINO GROSSO */

				/* INICIO MERIDIANO Estômago (Wei) - Zu Yang Ming Wei Jing */

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e1k';
				object.position.x = -2.9677980068645167;
				object.position.y = 66.70000000000014;
				object.position.z = 3;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e2';
				object.position.x = -2.9677980068645167;
				object.position.y = 66.00000000000018;
				object.position.z = 3.2;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e3';
				object.position.x = -2.8677980068645166;
				object.position.y = 63.700000000000294;
				object.position.z = 3.8000000000000007;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e4';
				object.position.x = -2.7677980068645165;
				object.position.y = 61.10000000000026;
				object.position.z = 4.1000000000000005;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e5';
				object.position.x = -3.367798006864517;
				object.position.y = 58.200000000000216;
				object.position.z = 2.4999999999999996;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e6';
				object.position.x = -5.967798006864511;
				object.position.y = 61.30000000000026;
				object.position.z = -2.6000000000000028;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e7';
				object.position.x = -6.467798006864509;
				object.position.y = 64.20000000000029;
				object.position.z = -2.700000000000003;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e8';
				object.position.x = -6.26779800686451;
				object.position.y = 71.89999999999985;
				object.position.z = -2.700000000000003;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e9';
				object.position.x = -2.9677980068645167;
				object.position.y = 54.20000000000016;
				object.position.z = -2.3000000000000025;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e10';
				object.position.x = -2.267798006864516;
				object.position.y = 51.40000000000012;
				object.position.z = -2.2000000000000024;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e11';
				object.position.x = -2.9677980068645167;
				object.position.y = 47.600000000000065;
				object.position.z = -1.2000000000000015;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e12';
				object.position.x = -6.667798006864508;
				object.position.y = 48.60000000000008;
				object.position.z = -2.2000000000000024;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e13';
				object.position.x = -7.067798006864507;
				object.position.y = 47.600000000000065;
				object.position.z = -1.0000000000000013;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e14';
				object.position.x = -7.667798006864505;
				object.position.y = 44.800000000000026;
				object.position.z = 0.8999999999999986;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e15';
				object.position.x = -8.767798006864501;
				object.position.y = 42.29999999999999;
				object.position.z = 2.3999999999999995;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e16';
				object.position.x = -9.867798006864497;
				object.position.y = 38.89999999999994;
				object.position.z = 4.2;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e17';
				object.position.x = -12.06779800686449;
				object.position.y = 33.19999999999986;
				object.position.z = 4.999999999999997;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e18';
				object.position.x = -12.06779800686449;
				object.position.y = 30.199999999999818;
				object.position.z = 2.1999999999999993;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e19';
				object.position.x = -3.167798006864517;
				object.position.y = 25.699999999999754;
				object.position.z = 6.599999999999992;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e20';
				object.position.x = -3.167798006864517;
				object.position.y = 22.64727272727248;
				object.position.z = 6.699999999999991;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e21';
				object.position.x = -3.167798006864517;
				object.position.y = 19.59454545454521;
				object.position.z = 6.699999999999991;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e22';
				object.position.x = -3.167798006864517;
				object.position.y = 16.541818181817938;
				object.position.z = 6.499999999999992;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e23';
				object.position.x = -3.167798006864517;
				object.position.y = 13.489090909090663;
				object.position.z = 6.699999999999991;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e24';
				object.position.x = -3.167798006864517;
				object.position.y = 10.43636363636339;
				object.position.z = 7.09999999999999;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e25';
				object.position.x = -3.167798006864517;
				object.position.y = 7.383636363636118;
				object.position.z = 6.99999999999999;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e26';
				object.position.x = -3.167798006864517;
				object.position.y = 4.330909090908847;
				object.position.z = 6.899999999999991;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e27';
				object.position.x = -3.167798006864517;
				object.position.y = 1.2781818181815723;
				object.position.z = 6.599999999999992;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e28';
				object.position.x = -3.167798006864517;
				object.position.y = -1.7745454545457022;
				object.position.z = 6.299999999999993;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e29';
				object.position.x = -3.167798006864517;
				object.position.y = -4.827272727272973;
				object.position.z = 5.699999999999995;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e30';
				object.position.x = -3.167798006864517;
				object.position.y = -7.880000000000244;
				object.position.z = 4.599999999999999;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e31';
				object.position.x = -12.467798006864488;
				object.position.y = -11.280000000000232;
				object.position.z = 4.100000000000001;
				scene.add( object );


				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e32';
				object.position.x = -12.467798006864488;
				object.position.y = -28.48000000000039;
				object.position.z = 4.300000000000001;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e33';
				object.position.x = -12.467798006864488;
				object.position.y = -36.2800000000005;
				object.position.z = 2.900000000000001;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e34';
				object.position.x = -12.467798006864488;
				object.position.y = -38.98000000000054;
				object.position.z = 2.3000000000000003;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e35';
				object.position.x = -12.467798006864488;
				object.position.y = -47.18000000000065;
				object.position.z = 1.4999999999999996;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e36';
				object.position.x = -12.467798006864488;
				object.position.y = -53.18000000000074;
				object.position.z = -0.10000000000000153;
				scene.add( object );


				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e37';
				object.position.x = -12.467798006864488;
				object.position.y = -63.68000000000089;
				object.position.z = -0.7000000000000015;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e38';
				object.position.x = -11.76779800686449;
				object.position.y = -69.78000000000057;
				object.position.z = -1.6000000000000019;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e39';
				object.position.x = -11.367798006864492;
				object.position.y = -73.28000000000037;
				object.position.z = -1.9000000000000021;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e40';
				object.position.x = -13.467798006864484;
				object.position.y = -69.48000000000059;
				object.position.z = -4.3000000000000025;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e41';
				object.position.x = -8.667798006864501;
				object.position.y = -85.1799999999997;
				object.position.z = -0.8000000000000016;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e42';
				object.position.x = -9.967798006864497;
				object.position.y = -88.27999999999952;
				object.position.z = 0.9999999999999983;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e43';
				object.position.x = -8.8677980068645;
				object.position.y = -90.97999999999936;
				object.position.z = 6.099999999999993;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e44';
				object.position.x = -9.467798006864498;
				object.position.y = -91.87999999999931;
				object.position.z = 7.799999999999988;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e45';
				object.position.x = -9.967798006864497;
				object.position.y = -93.17999999999924;
				object.position.z = 11.299999999999976;
				scene.add( object );

				/* FIM MERIDIANO Estômago (Wei) - Zu Yang Ming Wei Jing */
				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {

					console.log( item, loaded, total );
					/* Escreve no console do browser o andamento do carregamento */

				};
				/* Gerenciador de carregamento vide https://threejs.org/docs/#Reference/Loaders/LoadingManager */

				var texture = new THREE.Texture();

				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};
				/* não sei do que se trata a variável xhr, mas essa função serve para retornar a quantidade em porcentagem de quanto já carregou e quanto falta carregar do OBJETO (corpo humano). Desconsiderar essa função */

				var onError = function ( xhr ) {
				};
				/* desconsiderar*/

				var loader = new THREE.ImageLoader( manager );
				loader.load( 'three/textura/UV_Grid_Sm.jpg', function ( image ) {

					texture.image = image;
					texture.needsUpdate = true;

				} );
				/* Carrega a textura vide https://threejs.org/docs/#Reference/Loaders/ImageLoader */

				var loader = new THREE.OBJLoader( manager );
				/* instancia o carregador de objeto vide https://threejs.org/docs/#Reference/Loaders/OBJLoader */
				var material = new THREE.MeshBasicMaterial({color: 'yellow', side: THREE.DoubleSide});
				/* desconsiderar, aplica a cor ao objeto - só aparece sem a textura */
				loader.load( 'three/modelo/corpo.obj', function ( object ) {

					object.traverse( function ( child ) {

						if ( child instanceof THREE.Mesh ) {

							child.material.map = texture;

						}

					} );

					object.position.y = - 95;
					scene.add( object );

				}, onProgress, onError );
				/* carrega o objeto corpo.obj e aplica a textura */
				raycaster = new THREE.Raycaster();
				/* declara a variavel raycaster, que é instanciada pelo construtor Raycaster(), usado para clicar em objetos tridimensionais - funciona como um raio projetado ao longo do eixo Z, (o mouse trabalha em 2 dimensoes), o raycaster faz um procedimento que quando o mouse é clicado, vai verificando-se ao longo da reta Z com os eixos X e Y fixados pela POSIÇÃO do mouse. Quando um objeto é encontrado, ele é adicionado à um vetor de INTERSECÇÕES. Podendo assim acessá-lo e verificar quais objetos estão no caminho. */
				renderer = new THREE.WebGLRenderer();
				/* O renderizador WebGL exibe a cena trabalhada usando o WebGL, se o dispositivo suportar.*/

				renderer.setPixelRatio( window.devicePixelRatio );
				/* Define a proporção de pixel do dispositivo em questão, passando como parâmetro esta informação, obtida pelo comando window.devicePixelRatio. Geralmente usado para dispositivos HiDPI, a fim de evitar sobreposição de imagens no CANVAS*/
				renderer.setSize( window.innerWidth, window.innerHeight );
				/* Define o tamanho da tela de renderização - neste caso o tamanho de ALTURA e LARGURA da janela (total)*/
				container.appendChild( renderer.domElement );
				/* Insere o elemento CANVAS no container, onde será renderizado o WebGL
				   A variável container foi declarada na linha 91 */

				window.addEventListener( 'keydown', keyDownTextField, false);

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				/*desconsiderar*/

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				/*Declara uma escuta para eventos de click do mouse. Cada vez que o mouse é clicado, a função onDocumentMouseDown é chamada.*/
				window.addEventListener( 'resize', onWindowResize, false );
				/*desconsiderar*/
			}

			function keyDownTextField(e) {
			    if (e.keyCode == '38') {
			    	uPressed = true;
			    }
			    else if (e.keyCode == '40') {
			        dPressed = true;
			    }
			    else if (e.keyCode == '37') {
			        lPressed = true;
			    }
			    else if (e.keyCode == '39') {
			    	rPressed = true;
			    }
			    else if (e.keyCode == '107') {
			    	pPressed = true;
			    }
			    else if (e.keyCode == '109') {
			    	mPressed = true;
			    }
			    else if (e.keyCode == '188') {
			    	controls.enabled = false;
			    }
			    else if (e.keyCode == '190') {
			    	controls.enabled = true;
			    }
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
			/*desconsiderar*/

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				mouseX = ( event.clientX - windowHalfX ) / 2;
				mouseY = ( event.clientY - windowHalfY ) / 2;

			}
			/*desconsiderar*/

			function onDocumentMouseDown( event ) {

				event.preventDefault();
				/* Faz cancelar qualquer ação padrão a ser executado durante o click do mouse. Prevenir uma ação inesperada, para tratar corretamente o clique do mouse */

				raycaster.setFromCamera( mouse, camera );
				/* Atualiza as informações FromCamera do raycaster onde
				mouse: coordenadas 2D do mouse.
				camera: camera pela qual o raio tem origem*/

				var intersects = raycaster.intersectObjects( scene.children );
				/*
					Executa o método que registra em um vetor os objetos encontrados ao longo do raio. Onde:
					scene.children: todos os objetos que serão verificados pelo raio. Neste caso, usa-se scene.children para incluir TODOS os objetos (filhos da cena).
				*/
				if ( intersects.length > 0 ) {
					/* intersects.lenght retorna a quantidade de elementos. Se a quantidade de elementos for > 0 faça: */

					if ( INTERSECTED != intersects[ 0 ].object ) {
						/* se o objeto não for na primeira posição (pois este é o corpo humano e ele sempre vai estar lá)
						FAÇA
						*/						
						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						/* Recupera a cor padrão do objeto (esfera no caso) */
						INTERSECTED = intersects[ 0 ].object;
						/* armazena na variavel INTERSECTED o objeto encontrado*/
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xff0000 );
						/* Altera a cor do objeto para vermelho(esfera no caso) */
						animacao = parent.document.getElementById(INTERSECTED.nome);
						/* recupera e armazena em animacao o elemento com o ID do nome da esfera*/
						console.log(INTERSECTED.name);
						console.log('\n\t\t\t\tobject.position.x = '+INTERSECTED.position.x+';\n\t\t\t\t'+'object.position.y = '+INTERSECTED.position.y+';\n'+'\t\t\t\tobject.position.z = '+INTERSECTED.position.z+';\n');
						//console.log('object.position.y = '+INTERSECTED.position.y+';\n');
						//console.log('object.position.z = '+INTERSECTED.position.z+';\n');
						//console.log(INTERSECTED.position.x, INTERSECTED.position.y, INTERSECTED.position.z);
						animacao.click();
						/*clica-se involuntariamente no objeto com o ID igual ao do NOME da esfera, fazendo abrir na pagina pai o botão relacionado com a esfera clicada */
					}
				} else {
					/* caso contrário */
					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					/*  atualiza a esfera para a cor padrão, visto que o clique foi em outra coisa que não foi a última esfera clicada */

					INTERSECTED = null;

				}
			}

			function acuPonto(x, y, z) {
			/* declaração da função acuPonto, que recebe apenas as 3 coordenadas onde a câmera irá se aproximar */
				acuX = x;
				acuY = y;
				acuZ = z;
				/* armazena as coordenadas recebidas por parâmetro nas variáveis globais para uso posterior */
				
				p.set( acuX, acuY, acuZ );
				/* p é um vetor tridimensional declarado na linha 41
				aqui estamos alterando os valores de sua coordenada, para os valores recebidos pela função */

				focoCamera = true;
				/* aqui definimos a variavel global focoCamera para TRUE, ela fora declarada como FALSE na linha 39 */
			}

			function animate() {
				/* pequena função com duas instruções, mas responsável por animar a câmera chamando-a recursivamente */
				requestAnimationFrame( animate );
				/* função nativa do javascript, introduzida recentemente. Sanou varios problemas que persistiam quando utilizávamos setInterval(), deixando todo o gerenciamento de tempo e hardware para o navegador. Seria interessante falar sobre isso,
				mas basicamente com este comando podemos realizar uma animação por X frames por segundo, passando uma função que será re-executada infinitas vezes - neste caso a função animate está sendo chamada recursivamente. */
				render();
				/* chama a função render agora com os valores atualizados pela mesma função render, criando uma espécie de animação frame a frame*/
			}

			function render() {
				/* função responsável por renderizar a cena */
				renderer.render( scene, camera );
				/* renderiza uma cena utilizando uma câmera, neste caso, scene e camera */
				if (uPressed) {
					var obj = scene.getObjectByName(idponto);
					obj.position.y = obj.position.y+0.1;
					uPressed = false;
				}
				if (dPressed) {
					var obj = scene.getObjectByName(idponto);
					obj.position.y = obj.position.y-0.1;
					dPressed = false;
				}
				if (lPressed) {
					var obj = scene.getObjectByName(idponto);
					obj.position.x = obj.position.x-0.1;
					lPressed = false;
				}
				if (rPressed) {
					var obj = scene.getObjectByName(idponto);
					obj.position.x = obj.position.x+0.1;
					rPressed = false;
				}
				if (pPressed) {
					var obj = scene.getObjectByName(idponto);
					obj.position.z = obj.position.z-0.1;
					pPressed = false;
				}
				if (mPressed) {
					var obj = scene.getObjectByName(idponto);
					obj.position.z = obj.position.z+0.1;
					mPressed = false;
				}
				if (focoCamera) { // SE (focoCamera == TRUE) faça
					/* variável global que é definida como TRUE quando é clicado em uma esfera ou clicada em um botão referente à um acuponto na barra lateral
					Basicamente, é a estrutura de condição que faz acontecer a animação da câmera
					*/
					if (camera.position.x != acuX) { /* Se a posição da câmera no eixo x for diferente do ponto que queremos chegar FAÇA */
						if (camera.position.x > acuX) { // se a posição da camera em X for maior que o valor de X que queremos chegar
							camera.position.x--; // Incrementa 1 unidade o valor da posição da camera.x
						} else { // caso contrário
							camera.position.x++; // Decrementa 1 unidade o valor da posição da camera.x
						}
						if (Math.round(camera.position.x) == Math.round(acuX)) { // Se o valor INTEIRO da posição da camera.x for IGUAL ao valor INTEIRO da posição do ponto pretendido
							camera.position.x = acuX;
							//a posição da camera em x recebe o valor exato do acuponto em x.
						}
					}


					if (camera.position.y != acuY) {
						/* Se a posição da câmera no eixo y for diferente do ponto que queremos chegar FAÇA */
						if (camera.position.y > acuY) { // se a posição da camera em Y for maior que o valor de Y do acuponto que queremos chegar
							camera.position.y--; // Decrementa 1 unidade o valor da posição da camera.y
						} else {
							camera.position.y++; // Incrementa 1 unidade o valor da posição da camera.y
						}
						
						if (Math.round(camera.position.y) == Math.round(acuY)) { // Se o valor INTEIRO da posição da camera.x for IGUAL ao valor INTEIRO da posição do ponto pretendido
							camera.position.y = acuY;
							//a posição da camera em y recebe o valor exato do acuponto em y.
						}
					}

					if (camera.position.z != acuZ+45) {
						/* Se a posição da câmera no eixo z for diferente do acuponto na posição Z+45 (+45 pois a camera do eixo Z deve ficar um pouco afastada e não grudada no ponto) que queremos chegar FAÇA */
						if (camera.position.z > acuZ+45) { // se a posição da camera em Z for maior que o valor de Z+45 do acuponto que queremos chegar
							camera.position.z--; // Decrementa 1 unidade o valor da posição da camera.z
						} else {
							camera.position.z++; // Incrementa 1 unidade o valor da posição da camera.z
						}
						if (Math.round(camera.position.z) == Math.round(acuZ+45)) { // Se o valor INTEIRO da posição da camera.z for IGUAL ao valor INTEIRO da posição z+45 do ponto pretendido
							camera.position.z = acuZ+45;
							//a posição da camera em z recebe o valor exato do acuponto em z.
						}
					}
					if ((camera.position.z == acuZ+45)&&(camera.position.y == acuY)&&(camera.position.x == acuX)) {
						focoCamera = false;
						controls.target = p;
						return;
					} /* se todas as condições estiverem satisfeitas, que é a camera exatamente no acuponto selecionado (exceto em z, que é z+45 para a camera nao ficar grudada no ponto), então alteramos a variável global focoCamera para FALSE, portanto quando entrar na função render novamente será verificada esta variável, e como ela estará FALSE não entrará nessas condições para animação. A única forma de focoCamera tornar-se TRUE será quando for clicado em um acuponto ou em um botão na barra lateral */
					camera.lookAt( p );
					/* lookAt( p ) => Em p está armazenada a coordenada do ponto em questão (onde a camera deverá se aproximar), portanto invocamos o metodo da camera -> lookAt(p) que recebe como parâmetro um ponto do tipo vetor tridimensional (neste caso, p) para que a câmera fique "olhando" para o ponto enquanto ela se aproxima (torna a animação mais agradavel, fica focada no ponto)*/
				}
			}

		</script>
	</body>
</html>
